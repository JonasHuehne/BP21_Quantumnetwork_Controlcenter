package keyGeneration;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.SQLException;
import java.time.Duration;
import java.time.Instant;
import java.util.Random;

import exceptions.ConnectionAlreadyExistsException;
import exceptions.EndpointIsNotConnectedException;
import exceptions.IpAndPortAlreadyInUseException;
import exceptions.KeyGenRequestTimeoutException;
import exceptions.ManagerHasNoSuchEndpointException;
import exceptions.VerificationFailedException;
import frame.Configuration;
import graphicalUserInterface.GenericWarningMessage;
import keyStore.KeyStoreDbManager;
import messengerSystem.MessageSystem;
import messengerSystem.SignatureAuthentication;
import networkConnection.ConnectionEndpoint;
import networkConnection.ConnectionManager;
import networkConnection.ConnectionState;
import networkConnection.MessageArgs;
import networkConnection.NetworkPackage;
import networkConnection.NetworkTimeoutThread;
import networkConnection.TransmissionTypeEnum;
import qnccLogger.Log;
import qnccLogger.LogSensitivity;


/**This class contains everything that it needed to generate a secure key.
 * After the key is generated, it is stored in the KeyDB.
 * 
 * @author Jonas Huehne, Sasha Petri
 *
 */
public class KeyGenerator implements Runnable{
	
	/** Owner of this KeyGenerator */
	private ConnectionEndpoint owner;
	
	private Path pythonPath; //The path to the folder with the python script
	private int initiative = 0;	//This is used to determine which side of a connection should execute which side of the KeyGenProcess
	private Path connectionPath;
	private Path localPath;
	private Thread transferThread;	//The thread running the KeyGen File Transfer Process 
	private String expectedOutgoingFilename = "out.txt";	//Use this to set the filename of the files that the python script wants to send to the other side of the connection.
	private String expectedIncomingFilename = "in.txt";	//Use this to set the filename of the files that the local python script should read from and then delete.
	private String expectedKeyFilename = "key.txt";	//Use this to set the filename of the key file that is generated by the python script and then read by this program in order to store the key in the KeyDB.
	private String expectedTermination = "terminate.txt";	//Use this to set the filename of the terminate signal written by the local python script to signal this program to stop the KeyGen Process.
	private String expectedPythonTerm = "pythonTerm.txt";	//Use this to set the filename of the signal for the python script to terminate the KeyGen Process. This is created if the program was told to shutdown from the other side of the connection.
	private boolean keyGenRunning; //True if KeyGen is running
	private int hasBeenAccepted = 0; //This controls the waiting period while waiting for the KeyGenPartner to Accept(1) or Reject(-1).
<<<<<<< loggerForRemainingClasses
	private Log log = new Log(KeyGenerator.class.getName(), LogSensitivity.WARNING);
	
=======
	private ConnectionEndpoint SourceCE = null; //This is the CE that is connected to the Photon Source. It is a class Var because of the Timed Execution of SendSourceSignal().

>>>>>>> main
	/** Key Generation uses authenticated messages only */
	SignatureAuthentication authenticator;
	
	/**
	 * Constructor. <br>
	 * To be used by a ConnectionEndpoint when it is created.
	 * @param owner
	 * 		the owning ConnectionEndpoint
	 * @implNote
	 * 		This constructor accesses none of the fields of the owning ConnectionEndpoint. <br>
	 */
	public KeyGenerator(ConnectionEndpoint owner) {
		this.owner = owner;
		this.authenticator = MessageSystem.getAuthenticator();
	}
	
	/**
	 * @return {@linkplain ConnectionEndpoint#getID()} for the owner of this KeyGenerator
	 */
	private String getOwnerID() {
		return owner.getID();
	}
	
	/**Returns true if the generator is running.
	 * Used when determining the CEs State.
	 * 
	 * @return true if actively generating a new key.
	 */
	public Boolean isKeyGenRunning() {
		return keyGenRunning;
	}
	
	/**Generate a Key by using the python scripts and acting as a middleman between both involved parties,
	 *  by handling the network side of the key generation as well as storing the key in the KeyDB.
	 * @throws KeyGenRequestTimeoutException 
	 * 		if a timeout occurs, i.e. the communication partner does not respond in time to the request
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 */
	public void generateKey() throws KeyGenRequestTimeoutException, EndpointIsNotConnectedException {
		log.logInfo("[" + getOwnerID() + "]: Starting KeyGenProcess!");
		//Check if everything is ready
		log.logInfo("[" + getOwnerID() + "]: Performing preGenChecks!");
		if(!preGenChecks()) {
			log.logWarning("[" + getOwnerID() + "]: Generation of Key did not start, preGenChecks failed!");
			return;
		}
		
		log.logInfo("[" + getOwnerID() + "]: Performing preGenSync!");
		//Wait for syncConfirm message before continuing.
		if(!preGenSync()) {
			log.logWarning("[" + getOwnerID() + "]: preGenSync failed!");
			return;
		}
		log.logInfo("[" + getOwnerID() + "]: preGenSync successful");
		initiative = 1;
		
		log.logInfo("[" + getOwnerID() + "]: Starting KeyGen MessagingService");
		
		//Signal the Source
		try {
			signalSourceAPI();
		} catch (NumberFormatException | ManagerHasNoSuchEndpointException | EndpointIsNotConnectedException e) {
			System.err.println("[" + getOwnerID() + "]: Error while contacting the Photon Source! " + e);
		}
		
		//Start the process
		keyGenMessagingService();
	}
	
	/**This calls the python script that was set in the Settings.
	 * The script is expected to be in localFolder/python/
	 */
	private void signalPython() {
		try {
			String command = "python " + pythonPath.resolve(Configuration.getProperty("PythonName")) + " " + initiative + " " + connectionPath;
			log.logInfo("[" + getOwnerID() + "]: Calling python script: " + command);
			Runtime.getRuntime().exec(command);
		} catch (IOException e) {
			System.err.println("[" + getOwnerID() + "]: Error while calling the python script for the key generation! " + e);
		}
	}
	
	/**Method for signaling the source API.
	 * This will send an authenticated Message to the Source Server.
	 * @throws NumberFormatException 
	 * 		if the value saved in the config file under "SourcePort" is not an Integer
	 * @throws ManagerHasNoSuchEndpointException 
	 * 		if the {@linkplain ConnectionManager} in the {@linkplain MessageSystem} does not contain the {@linkplain ConnectionEndpoint} that this KeyGenerator belongs to
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 */
	private void signalSourceAPI() throws NumberFormatException, ManagerHasNoSuchEndpointException, EndpointIsNotConnectedException {
<<<<<<< loggerForRemainingClasses
		log.logInfo("[" + getOwnerID() + "]: Calling the Photon Source.");
		/*
=======
		System.out.println("[" + getOwnerID() + "]: Calling the Photon Source.");
		
>>>>>>> main
		//Create connection to Source Server
		String sourceServerConnectionName = "SourceServer_" + generateRandomString();
		SourceCE = null;
		System.out.println("[" + getOwnerID() + "]: Creating Connection to Photon Source.");
		try {
			SourceCE = MessageSystem.conMan.createNewConnectionEndpoint(sourceServerConnectionName, Configuration.getProperty("SourceIP"), Integer.valueOf(Configuration.getProperty("SourcePort")), Configuration.getProperty("SourceSignature"));
		} catch (NumberFormatException | ConnectionAlreadyExistsException | IpAndPortAlreadyInUseException e) {
			System.err.println("[" + getOwnerID() + "]: Error while creating Connection to Photon Source. " + e);
			e.printStackTrace();
		}
		
		try {
			NetworkTimeoutThread NTT = new NetworkTimeoutThread(2000, this, this.getClass().getMethod("sendSourceSignal"));
			System.out.println("Starting Delayed Source Signal Timer.");
			NTT.start();
		} catch (NoSuchMethodException | SecurityException e) {
			System.err.println("Error while running timed method call for source signal: " + e);
		}

		
	}
	
	/**This method send the Photon Source a signal.
	 * It is a separate method to use the timer based call functionality.
	 * 
	 */
	public void sendSourceSignal() {
		//File name will be UserName_Date_RandomString 
		System.out.println("Timer is Up, sending actual Source signal now!");
		// (possibly change this to use localName saved in CE? Might be more unit testable)
		String filename = Configuration.getProperty("UserName") + "_" + new Date().toString().replace(':', '-') + "_" + generateRandomString();
		System.out.println("[" + getOwnerID() + "]: Filename: " + filename);
		//Message will be OwnServerIP_OwnServerPort_RemoteServerIP_RemoteServerPort
		String sourceInfo = Configuration.getProperty("UserIP") + "_" 
							+ Configuration.getProperty("UserPort") + "_" 
							+ owner.getRemoteAddress() 
							+ "_" + owner.getRemotePort();
		System.out.println("[" + getOwnerID() + "]: SourceInfo: " + sourceInfo);
		byte[] sourceInfoAsBytes = MessageSystem.stringToByteArray(sourceInfo);
		MessageArgs sourceSignalArgs = new MessageArgs(filename, -1);
		NetworkPackage signalToSource = new NetworkPackage(TransmissionTypeEnum.KEYGEN_SOURCE_SIGNAL, sourceSignalArgs, sourceInfoAsBytes, false);
		//signalToSource.sign(authenticator);
		if(SourceCE != null) {
			System.out.println("[" + getOwnerID() + "]: Sending Message to Source");
			try {
				SourceCE.pushMessage(signalToSource);
			} catch (EndpointIsNotConnectedException e) {
				System.err.println("[" + getOwnerID() + "]: Error while sending Source Signal: " + e);
			}
		}
		System.out.println("[" + getOwnerID() + "]: --------Completed Photon Source Interaction--------");
	}
	
	/**This method generates a random String. This is used to generate a filename for the source signal in signalSourceAPI().
	 * 
	 * @return the random String.
	 */
	public static String generateRandomString() {
		Random randomGen = new Random();
	    return randomGen.ints(48, 123).filter(i -> (i<=57||i>=65) && (i<=90||i>=97)).limit(16).collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();
	}

	
	/**Returns true only if all checks are completed successfully.
	 * 
	 * @return
	 * 		true iff key generation can be started <br>
	 * 		false otherwise
	 */
	private boolean preGenChecks() {

		boolean isConnectedToPartner = owner.reportState().equals(ConnectionState.CONNECTED);
		
		//TODO: Add any future Reqs here!
		
		return isConnectedToPartner;
		
	}
	
	/**This is used to signal if the other Party has accepted or rejected the proposal to generate a key.
	 * 
	 * @param response 1 = Accepted, -1 = Rejected, 0 = Default/Undecided.
	 */
	public void updateAccRejState(int response) {
		hasBeenAccepted = response;
	}
	
	/**Returns true if both ends of the keyGen process agree to begin the generation process.
	 * 
	 * @return true means the other party agreed and is checked and ready.
	 * @throws KeyGenRequestTimeoutException 
	 * 		if a timeout occurs, i.e. the communication partner does not respond in time to the request
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 */
	private boolean preGenSync() throws KeyGenRequestTimeoutException, EndpointIsNotConnectedException {
		
		//Send Sync Request		
		NetworkPackage keyGenSyncRequest = new NetworkPackage(TransmissionTypeEnum.KEYGEN_SYNC_REQUEST, false);
		keyGenSyncRequest.sign(authenticator);
		
		try {
			MessageArgs args = new MessageArgs();
			System.err.println("[" + getOwnerID() + "]: Sending preGenSync-Request!");
			MessageSystem.sendMessage(owner.getID(), TransmissionTypeEnum.KEYGEN_SYNC_REQUEST, args, MessageSystem.stringToByteArray("KEYGEN_SYNC_REQUEST"), true, false);
		} catch (EndpointIsNotConnectedException | ManagerHasNoSuchEndpointException e) {
			System.err.println("Failed to sendMessage() for KeyGenSync. " + e);
			return false;
		}
		
		Instant startWait = Instant.now();
		Instant current;
		//Wait for Answer
		hasBeenAccepted = 0;
		while(hasBeenAccepted == 0) {
			//Wait for KeyGenResponse
			if(hasBeenAccepted != 0) {
				break;
			}
			
			current = Instant.now();
			if(Duration.between(startWait, current).toSeconds() >= 10) {
				hasBeenAccepted = 0;
				System.out.println("TimeOut while waiting for response!");
				throw new KeyGenRequestTimeoutException("[" + getOwnerID() + "]: Time-out while waiting for Pre-Key-Generation Sync. Did not receive an Accept- or Reject-Answer in time");
			}
		}
		
		if(hasBeenAccepted>0) {
			log.logInfo("SyncRequest Accepted!");
			hasBeenAccepted = 0;
			return true;
		}
		
		log.logWarning("SyncRequest Rejected!");
		new GenericWarningMessage(getOwnerID() +": Key Generation was rejected by communication Partner!");
		hasBeenAccepted = 0;
		return false;
	}
	
	
	/**This is called if a message asking for preGenSync was received. 
	 * It will ask the user if the keyGenProcess should be started and sends the appropriated message back.
	 * @param msg
	 * 		the received message
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 */
	public void keyGenSyncResponse(NetworkPackage msg) throws EndpointIsNotConnectedException {
		// verify the received message
		System.out.println("Reacting to SyncRequest!");
		boolean verified = msg.verify(authenticator, getOwnerID());
		if (!verified)  {
			System.out.println("SyncRequest could not be verified!");
			return;
		}
		System.out.println("SyncRequest was verified!");
		//for now, always accept
		boolean accept = true;
		System.out.println("Running preGenChecks...");
		if(accept && preGenChecks()) {
			System.out.println("preGenChecks successful.");
			MessageArgs args = new MessageArgs();
			try {
				MessageSystem.sendMessage(owner.getID(), TransmissionTypeEnum.KEYGEN_SYNC_ACCEPT, args, MessageSystem.stringToByteArray("KEYGEN_SYNC_ACCEPT"), true, false);
			} catch (EndpointIsNotConnectedException | ManagerHasNoSuchEndpointException e) {
				System.err.println("Failed to respond to react to KeyGenSync-Request. " + e);
				return;
			}
	
			
			initiative = 0;
			keyGenMessagingService();
		}else {
			System.out.println("preGenChecks failed.");
			new GenericWarningMessage(getOwnerID() +"A Key Generation Request for " + owner + "had to be rejected!");
			MessageArgs args = new MessageArgs();
			try {
				MessageSystem.sendMessage(owner.getID(), TransmissionTypeEnum.KEYGEN_SYNC_REJECT, args, MessageSystem.stringToByteArray("KEYGEN_SYNC_REJECT"), true, false);
			} catch (EndpointIsNotConnectedException | ManagerHasNoSuchEndpointException e) {
				System.err.println("Failed to respond to react to KeyGenSync-Request. " + e);
				return;
			}
		}
		
	}
	
	/**This calls the python script and also starts the threads that handle the .txt files.
	 * 
	 */
	private void keyGenMessagingService() {
		if(!setUpFolders()) {
			log.logWarning("[" + getOwnerID() + "]: Aborting KeyGenMessagingService, some Folders could not be found!");
			return;
		}
		
		//Remove potential remnant from a previous, terminated attempt
		if(Files.exists(connectionPath.resolve(expectedPythonTerm))){
			try {
				Files.deleteIfExists(connectionPath.resolve(expectedPythonTerm));
			} catch (IOException e) {
				log.logError("[" + getOwnerID() + "]: Failed while cleaning up pythonterm file from previous generation process. Attempted to delete file " + connectionPath.resolve(expectedPythonTerm).toString(), e);
				return;
			}
		}
		
		//calling python
		signalPython();
		
		
		transferData();
		
	}
	
	
	/**This starts the actual thread that deals with the message handling.
	 * 
	 */
	private void transferData() {
		log.logInfo("[" + getOwnerID() + "]: Starting KeyGen File Transfer Service.");
		if(keyGenRunning) {
			log.logWarning("Error: Key Gen Thread was already running, could not start a second one!");
		}
		transferThread = new Thread(this, getOwnerID() + "_transferThread");
		keyGenRunning = true;
		transferThread.start();
	}
	
	/**Checks and prepares all necessary folders.
	 * 
	 * @return Returns true if it found the python Script folder and created or found a folder with the name of the connectionEndpoint that owns this KeyGenerator.
	 */
	private boolean setUpFolders() {
		
		//Get own root folder
		Path currentWorkingDir = Path.of(Configuration.getBaseDirPath());
        localPath = currentWorkingDir;
        
        //Get python folder
        Path pythonScriptLocation = localPath.resolve("python");
        if(!Files.isDirectory(pythonScriptLocation)) {
        	log.logWarning("[" + getOwnerID() + "]: Error, could not find the Python Script folder, expected: " + pythonScriptLocation.normalize().toString());
        	return false;
        }
        pythonPath = pythonScriptLocation;
        
        //Prepare Connection Folder
        Path connectionFolderLocation = currentWorkingDir.resolve("connections");
        connectionFolderLocation = connectionFolderLocation.resolve(getOwnerID());
        if(!Files.isDirectory(connectionFolderLocation)) {
        	log.logWarning("[" + getOwnerID() + "]: Could not find the Connection folder for "+ getOwnerID() +", expected: " + connectionFolderLocation.normalize().toString() + " Creating folder now!");
        	try {
				Files.createDirectories(connectionFolderLocation);
			} catch (IOException e) {
				log.logError("[" + getOwnerID() + "]: Error: Could not create Connection Folder!", e);
				return false;
			}
        }else {
        	log.logInfo("[" + getOwnerID() + "]: Connection Folder found.");
        }
        connectionPath = connectionFolderLocation;
        
		return true;
	}
	
	
	/**Transfers the contents of a key.txt file to the DB.
	 * Needs to be adjusted if the DB is not changed to use Byte[].
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 * @throws SQLException this is thrown if there is an issue if interacting wiht the KeyStore DB.
	 */
	private void transferKeyFileToDB() throws EndpointIsNotConnectedException, SQLException {
		//Read Key from File
		byte[] key = null;
		Path keyFilePath = connectionPath.resolve(expectedKeyFilename);
		if(Files.exists(keyFilePath) && Files.notExists(connectionPath.resolve(expectedKeyFilename + ".lock"))) {
			try {
				//Read
				key = Files.readAllBytes(keyFilePath);
				
				//Delete
				try {
					Files.delete(keyFilePath);
				} catch (IOException e) {
					e.printStackTrace();
				}
			} catch (IOException e) {
				log.logWarning("[" + getOwnerID() + "]: Error while reading the Key File!");
				e.printStackTrace();
			}
		}else {
			log.logWarning("[" + getOwnerID() + "]: Error while trying to read the Key File! Either no " + expectedKeyFilename + " file was found or there was still a .lock file present!");
		}
		
		//Insert into DB
		String ownAddress = owner.getLocalAddress();
		int ownPort = owner.getServerPort();
		
		String remoteAddress = owner.getRemoteAddress();
		int remotePort = owner.getRemotePort();
		
		//Store the new Key in the KeyDB
		KeyStoreDbManager.createNewKeyStoreAndTable();
		//Overwrite if Key already exists for connectionID
		if(KeyStoreDbManager.doesKeyStreamIdExist(getOwnerID())) {
			KeyStoreDbManager.deleteEntryIfExists(getOwnerID());
		}
		KeyStoreDbManager.insertToKeyStore(getOwnerID(), key, ownAddress + ":" + String.valueOf(ownPort), remoteAddress + ":" + String.valueOf(remotePort), false, initiative == 1);
		
		//End the KeyGen Process and clean up.
		shutdownKeyGen(false, false);
		new GenericWarningMessage("Key Generation Successful!\nThe new Key has been added to the Key Database.");
	}
	
	/**This handles the shutdown of the KeyGen. It is called locally and removes all files that may be left behind.
	 * It is called if the process is aborted/terminated or completed. If relay == true, this also calls the other involved party.
	 * 
	 * @param relay if True, this will cause a network Message to be sent.
	 * @param informPython if True, the shutdown originates from inside this program and not from a key- or shutdown-file. As such, the pythonScript needs to me notified about this via an expectedPythonTerm-file.
	 * @throws EndpointIsNotConnectedException 
	 * 		if the {@linkplain ConnectionEndpoint} owning this KeyGenerator is not connected to its partner at the moment
	 */
	public void shutdownKeyGen(boolean relay, boolean informPython) throws EndpointIsNotConnectedException {
		
		log.logInfo("[" + getOwnerID() + "]: Shutting down the KeyGen of " + getOwnerID());
		keyGenRunning = false;
		try {
			if(connectionPath != null) {
				Files.deleteIfExists(connectionPath.resolve(expectedOutgoingFilename));
				Files.deleteIfExists(connectionPath.resolve(expectedOutgoingFilename + ".lock"));
				Files.deleteIfExists(connectionPath.resolve(expectedIncomingFilename));
				Files.deleteIfExists(connectionPath.resolve(expectedIncomingFilename + ".lock"));
				Files.deleteIfExists(connectionPath.resolve(expectedKeyFilename));
				Files.deleteIfExists(connectionPath.resolve(expectedKeyFilename + ".lock"));
				Files.deleteIfExists(connectionPath.resolve(expectedTermination));
				Files.deleteIfExists(connectionPath.resolve(expectedTermination + ".lock"));
			}
			
			if(relay) {
				NetworkPackage keyGenTerminationRequest = new NetworkPackage(TransmissionTypeEnum.KEYGEN_TERMINATION, false);
				keyGenTerminationRequest.sign(authenticator);
				owner.pushMessage(keyGenTerminationRequest);
			}
			if(informPython && connectionPath != null) {
				//Signal the local python script that the other end of the connection has terminated the KeyGen Process
				Writer pythonTermWriter = new BufferedWriter(
						new OutputStreamWriter(Files.newOutputStream(connectionPath.resolve(expectedPythonTerm)), Configuration.getProperty("Encoding")));
				pythonTermWriter.write("");
			}
			
		} catch (IOException e) {
			log.logError("[" + getOwnerID() + "]: Error while shutting down the KeyGen and deleting any potentially existing Files!", e);
		}
	}
	
	/**This is the tread that runs in the background and listens for .txt files, reads/writes them and then sends and deletes the files where needed. <br>
	 * <b> To avoid unstable behavior </b> if this is called while the owning {@linkplain ConnectionEndpoint} is not in the current
	 * {@linkplain ConnectionManager} of the {@linkplain MessageSystem}, this method will immediately return. It will also immediately return
	 * if the owner of this keyGenerator is not connected to their partner CE at the moment.
	 * 
	 */
	@Override
	public void run() {

		/*
		 * Safety check:
		 *  - Manager of the MessageSystem should own this endpoint
		 *  - Owning Endpoint should be CONNECTED
		 * Otherwise, return.
		 */
		if (!MessageSystem.conMan.hasConnectionEndpoint(owner.getID())) return;

		try {
			if (!(MessageSystem.conMan.getConnectionState(getOwnerID()).equals(ConnectionState.CONNECTED) || MessageSystem.conMan.getConnectionState(getOwnerID()).equals(ConnectionState.GENERATING_KEY))) return;
		} catch (ManagerHasNoSuchEndpointException e1) {
			return;
		}
		
		Path outFilePath = connectionPath.resolve(expectedOutgoingFilename);

		try {
			while(keyGenRunning) {	
				
				//Part 1
				//Read outgoing file and send it.
				if(Files.exists(outFilePath) && Files.notExists(connectionPath.resolve(expectedOutgoingFilename + ".lock"))) {

					//Read FileContent
					byte[] outFileContent = null;
					try {
						outFileContent = Files.readAllBytes(outFilePath);
					} catch (IOException e) {
						log.logError("Error, could not read outgoing file", e);
					}
					
				    //Send FileContent
					MessageArgs args = new MessageArgs();
					NetworkPackage keygenTransmission = new NetworkPackage(TransmissionTypeEnum.KEYGEN_TRANSMISSION, args, outFileContent, false);
					keygenTransmission.sign(authenticator);
					owner.pushMessage(keygenTransmission);
					
				    //Clear File Content
				    outFileContent = null;
				    
				    //Delete out.txt
				    try {
						Files.delete(outFilePath);
					} catch (IOException e) {
						log.logError("Error, could not delete outgoing file", e);
					}
				}else {
					//Check for non-transmission Files
					
					//Key Result
					if(Files.exists(connectionPath.resolve(expectedKeyFilename)) && Files.notExists(connectionPath.resolve(expectedKeyFilename + ".lock"))) {
						log.logInfo("[" + getOwnerID() + "]: Adding Key to KeyDB");
							transferKeyFileToDB();
						return;
					}
					
					
					//Abort Signal File
					if(Files.exists(connectionPath.resolve(expectedTermination)) && Files.notExists(connectionPath.resolve(expectedTermination + ".lock"))) {
						log.logInfo("[" + getOwnerID() + "]: Aborting Key Generation");
					
						Files.delete(connectionPath.resolve(expectedTermination));
						shutdownKeyGen(true, false);
						return;
					}	
				}
			}
		} catch (UnsupportedEncodingException e) {
			log.logError("ERROR - Key Generation was unsuccessful. The Encoding specified in the Configuration file was not valid.", e);
		} catch (EndpointIsNotConnectedException e) {
			log.logError("ERROR - Key Generation was unsuccessful. "
					+ "The endpoint " + getOwnerID() + " is not connected to its partner at the moment. "
					+ "This resulted in an inability to send a message from that endpoint. See the stacktrace for details on where a message could not be sent. ", e);
		} catch (IOException | SQLException e) {
			log.logError("ERROR - Key Generation was unsuccessful. ", e);
		} finally {
			if (keyGenRunning) {
				// Always shut down the key generator if it is still running
				try {
					shutdownKeyGen(false, true);
				} catch (EndpointIsNotConnectedException e) {
					log.logError("An Error occured trying to shut down the key generator. "
							+ "The keyGenRunning variable has been manually set to false, but the key generator may be in an unstable state.", e);
					keyGenRunning = false;
				}
			}
		}
		
	}
	
	/**This is called whenever a NetworkPackage of type KEYGEN_TRANSMISSION is received during KeyGen.
	 * It is used to transmit the vital information needed for the KeyGen Process.
	 * 
	 * @param msg the NetworkPackage containing the KeyGen Information.
	 * @throws VerificationFailedException is thrown if the verification of the message fails.
	 * 		if the message could not be verified
	 */
	public void writeKeyGenFile(NetworkPackage msg) throws VerificationFailedException {
		Path inFilePath = connectionPath.resolve(expectedIncomingFilename);
		
		//Writing Incoming Files
		byte[] inFileContent;
		
		// Verify message is legit
		boolean verify = msg.verify(authenticator, getOwnerID());
		if (!verify) { 
			throw new VerificationFailedException("Could not verify message with ID " + msg.getStringID() + " and type "
					+ TransmissionTypeEnum.KEYGEN_TRANSMISSION + ". Discarded contents.");
		}
		
		//Receive Message
		inFileContent = msg.getContent();
		
		//Write temporary lock file
		File lockFile = new File(connectionPath.resolve(inFilePath + ".lock").toString());
		try {
			lockFile.createNewFile();
		} catch (IOException e1) {
			log.logError("[" + getOwnerID() + "]: Error while creating temp lock file for the new in.txt", e1);
		}
		//Write to file
		try
		(Writer inWriter = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(inFilePath), Configuration.getProperty("Encoding")))) {
			inWriter.write(MessageSystem.byteArrayToString(inFileContent));
<<<<<<< loggerForRemainingClasses
		} catch (Exception e) {
			log.logError("Error, could not write to incoming file", e);
=======
			inWriter.close();
		} catch (UnsupportedEncodingException e) {

			e.printStackTrace();
		} catch (FileNotFoundException e) {

			e.printStackTrace();
		} catch (IOException e) {

			e.printStackTrace();
>>>>>>> main
		}
		//Remove .lockFile
		lockFile.delete();
	}
}


