package encryptionDecryption;


import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.util.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Class for AES-256 encryption and decryption of Strings using the CBC Mode with a constant IV
 * 
 * @author Lukas Dentler
 *
 */
public class AES256 {
	
	//generating constant IV
	private static final byte[] byteIv = {42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42};
	private static final IvParameterSpec iv = new IvParameterSpec(byteIv);
	
	/**
	 * Used to convert a String with key data to a SecretKey object usable with javax.crypto.Cipher
	 * 
	 * @param str either a key generated by KeyGenerator for AES and then encrypted to String with Base64 or a bitString with 256 bits
	 * @return An instance of SecretKey used to encrypt or decrypt with javax.crypto.Cipher
	 * 		   returns null if str is not fulfilling the contracted specification.
	 */
	private static SecretKey stringToSecretKey(String str) {
		byte[] byteKey;
		
		
		if (str.length() != 256 && str.length() != 44) {
			System.out.println("An unvalid key was used. Please use either a key generated by KeyGenerator for AES and then encrypted to String with Base64 or a bitString with 256 bits");
			return null;
		}
		
		
		//deciding whether strKey is a bitString or generated String for Key
		if(str.length() == 256) {
			byteKey = bitString256ToByteArray32(str);
		}
		else {
			byteKey = Base64.getDecoder().decode(str);
		}
		
		//wrapping key information in SecretKey class for AES 
		SecretKey key = new SecretKeySpec(byteKey, 0, byteKey.length, "AES");
		return key;
	}
	
	/**
	 * Used to convert a bitString containing 256 bits into an byteArray containing 32 bytes
	 * 
	 * @param str A String containing 256 bits(0 or 1);
	 * @return A byteArray containing 32 bytes corresponding to the 256 bits of str
	 * 		   returns null if str is not fulfilling the contracted specification.
	 */
	private static byte[] bitString256ToByteArray32(String str) {
		
		byte[] bytes = new byte[32];
		int j = 0;
		
		if (str.length() != 256) {
			System.out.println("Please only use 256 char long bit strings");
			return null;
		}
		
		//converting bits from bitString into bytes that can be put into a byteArray
		for(int i=0; i < 32; i++) {
			bytes[j] = (byte) (Integer.valueOf(str.substring(i * 8, i * 8 + 8), 2) - 128);
			j++;
		}
		return bytes;
	}
	
	/**
	 * Encrypts the given plain text String using the AES-256 CBC algorithm and a suitable key
	 * 
	 * @param strPlaintext the plain text that should be encrypted
	 * @param strKey either a key generated by KeyGenerator for AES-256 and then encrypted to String with Base64
	 * 		  or a bitString with 256 bits
	 * @return A String containing the encrypted plain text, In case of an Error returns null
	 */
	public static String encrypt(String strPlaintext, String strKey) {
		
		//converting plain text to byteArray
		byte[] bytePlaintext = strPlaintext.getBytes(StandardCharsets.UTF_8);
		//byte[] bytePlaintext = Base64.getDecoder().;
		
		//generating SecretKey from String
		SecretKey key = stringToSecretKey(strKey);
		
		try {
			//get Cipher Instance
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			
			//initialize Cipher for encryption
			cipher.init(Cipher.ENCRYPT_MODE, key, iv);
			
			//perform encryption
			byte[] byteCiphertext = cipher.doFinal(bytePlaintext);
			
			//convert cipher text to string
			//String strCiphertext = byteCiphertext.toString();
			String strCiphertext = Base64.getEncoder().encodeToString(byteCiphertext);
			
			return strCiphertext;
		}
		//printing exceptions
		catch (InvalidKeyException e) {
			System.err.println("An unvalid Key was used. \n" + e.toString());
		}
		catch (IllegalBlockSizeException e) {
			System.err.println("The plaintext has the wrong length. \n" + e.toString());
		}
		catch (Exception e) {
			//TODO later printing exception to UI
			System.err.println("An ERROR occured during encryption:\n" + e.toString());
		}
		
		return null ;
	}
	
	
	/**
	 * Decrypts the given cipher text String using the AES-256 CBC algorithm and the corresponding key used to encrypt the cipher text
	 * 
	 * @param strCiphertext the cipher text that should be decrypted
	 * @param strKey the key used to encrypt the cipher text
	 * @return A String containing the decrypted cipher text 
	 */
	public static String decrypt(String strCiphertext, String strKey) {
		
		//converting cipher text to byteArray
		//byte[] byteCiphertext = strCiphertext.getBytes(StandardCharsets.UTF_8);
		byte[] byteCiphertext = Base64.getDecoder().decode(strCiphertext);
		
		//generating SecretKey from String
		SecretKey key = stringToSecretKey(strKey);
		
		try {
			//get Cipher Instance
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			
			//initialize Cipher for decryption
			cipher.init(Cipher.DECRYPT_MODE, key, iv);		
			
			//perform decryption
			byte[] bytePlaintext = cipher.doFinal(byteCiphertext);
			
			//convert plain text to string
			String strPlaintext = new String(bytePlaintext, StandardCharsets.UTF_8);
			//String strPlaintext = Base64.getEncoder().encodeToString(bytePlaintext);
			
			return strPlaintext;
		}
		//printing exceptions
		catch (InvalidKeyException e) {
			System.err.println("An unvalid Key was used. \n" + e.toString());
		}
		catch (IllegalBlockSizeException e) {
			System.err.println("The ciphertext has the wrong length, make sure to decrypt only text that has been encrypted first \n" + e.toString());
		}
		catch (BadPaddingException e) {
			System.err.println("An ERROR occured regarding the padding of the encrypted text. \n A common reason for this ERROR is that a different key was used for encryption and decryption\n" + e.toString());
		}
		catch (Exception e) {
			//TODO later printing exception to UI
			System.err.println("An ERROR occured during decryption:\n" + e.toString());
		}
		return null;
	}
	
	
}
