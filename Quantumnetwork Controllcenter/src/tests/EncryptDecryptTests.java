package tests;

import encryptionDecryption.AES256;
import encryptionDecryption.CryptoUtility;

import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.Base64;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import org.junit.Test;




public class EncryptDecryptTests {
	String original = "This is a Test!\"§$%&/()=?öäü to be fair a very long test text to see if it really works. So i am just going to smash my head on the keyboard a bit more: ajodaohglaenkohadoibhlaknowehojobhaskdjnfoaishcvon'#*_-:.,,;<>|adasogphopaidfhgvpoiiruhgaowenklödaioühoigüoh";
	String bitStringKey = "0101010110101011101010111011101010101010101010101110011110000011101010111010111011100011000011110111101111101011010101011010101010111000011101010111101011110110111110001111100001111100011111010101110101110101110101110111101111000001111111010101010111101111";
	String bitStringKeyWithChars = "abc1010110101011101010111011101010101010101010101110011110000011101010111010111011100011000011110111101111101011010101011010101010111000011101010111101011110110111110001111100001111100011111010101110101110101110101110111101111000001111111010101010111101111";
	String bitStringKeyShort = "01110101";
	String bitStringKeyLong = "0101010110101011101010111011101010101010101010101110011110000011101010111010111011100011000011110111101111101011010101011010101010111000011101010111101011110110111110001111100001111110101100011111010101110101110101110101110111101111000001111111010101010111101111";

	private final PrintStream standardOut = System.out;
	private final PrintStream standardErr = System.err;
	private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();
	private final ByteArrayOutputStream outputErrCaptor = new ByteArrayOutputStream();
	
	private final static String KEY_WRONG_SIZE = "An invalid key was used. Please use either a key generated by KeyGenerator for AES and then encrypted to String with Base64 or a bitString with 256 bits";
	private final static String INVALID_KEY_NULL = "An invalid Key was used. \r\n" + 
			"java.security.InvalidKeyException: No installed provider supports this key: (null)";
	private final static String BIT_STRING_WRONG_LENGTH = "Please only use 256 char long bit strings";
	private final static String KEYGEN_ERROR = "An ERROR occured during the keygeneration:";
	private final static String ALGORITHM_AES = "AES";
	
	
	@Test
	/*
	 * Testing encryption and decryption with a bit string as Key
	 */
	public void testEncryptionDecryptionBitStringKey(){
		String encrypted = AES256.encrypt(original, bitStringKey);
		String decrypted = AES256.decrypt(encrypted, bitStringKey);
			
		assertNotEquals(original,encrypted);
		assertNotEquals(encrypted,decrypted);
		assertEquals(decrypted,original);
	}
	
	@Test
	/*
	 * Testing encryption and decryption with a generated Key
	 */
	public void testEncryptionDecryptionGeneratedKey() {
		String strKey = "";
		try{
			KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM_AES);
			keyGen.init(256);
			SecretKey key = keyGen.generateKey();
			strKey = Base64.getEncoder().encodeToString(key.getEncoded());
		}
		catch (Exception e) {
			System.out.println(KEYGEN_ERROR +e.toString());
		}
			
		String encrypted = AES256.encrypt(original, strKey);
		String decrypted = AES256.decrypt(encrypted, strKey);
		
		assertNotEquals(original,encrypted);
		assertNotEquals(encrypted,decrypted);
		assertEquals(decrypted,original);
	}	
	
	@Test
	/*
	 * Testing that correct Exception is thrown, when bit string for key contains Chars during encryption
	 */
	public void testEncryptionBitStringContainsChars() {		
		assertThrows(NumberFormatException.class,() -> {
			assertNull(AES256.encrypt(original, bitStringKeyWithChars));
			});
	}
	
	@Test
	/*
	 * Testing that correct Error message is shown when using a too short bit string during encryption
	 */
	public void testEncryptionBitStringTooShort() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));

		assertNull(AES256.encrypt(original, bitStringKeyShort));
		
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}
	
	@Test
	/*
	 * Testing that correct Error message is shown when using a too long bit string during encryption
	 */
	public void testEncryptionBitStringTooLong() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));
		
		assertNull(AES256.encrypt(original, bitStringKeyLong));
		
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}
	
	@Test
	/*
	 * Testing that correct Error message is shown when using a generated key of wrong length during encryption
	 */
	public void testEncryptionGeneratedKeyWrongLength() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));
		
		String strKeyWrongLength = "";
		try{
			KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM_AES);
			keyGen.init(128);
			SecretKey key = keyGen.generateKey();
			strKeyWrongLength = Base64.getEncoder().encodeToString(key.getEncoded());
		}
		catch (Exception e) {
			System.out.println(KEYGEN_ERROR +e.toString());
		}
		
		assertNull(AES256.encrypt(original, strKeyWrongLength));
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}
	
	@Test
	/*
	 * Testing that correct Exception is thrown when null is used as key
	 */
	public void testEncryptionNullKey() {
		assertThrows(NullPointerException.class,() -> {
			assertNull(AES256.encrypt(original,(String) null));
			});
	}
	
	@Test
	/*
	 * Testing that correct Exception is thrown, when bit string for key contains Chars during decryption
	 */
	public void testDecryptionBitStringContainsChars() {
		String encrypted = AES256.encrypt(original, bitStringKey);
		assertThrows(NumberFormatException.class,() -> {
			assertNull(AES256.decrypt(encrypted, bitStringKeyWithChars));
		});
	}
	
	@Test
	/*
	 * Testing that correct Error message is shown when using a too short bit string during decryption
	 */
	public void testDecryptionBitStringTooShort() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));

		String encrypted = AES256.encrypt(original, bitStringKey);
		assertNull(AES256.decrypt(encrypted, bitStringKeyShort));
		
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}
	

	@Test
	/*
	 * Testing that correct Error message is shown when using a too long bit string during decryption
	 */
	public void testDecryptionBitStringTooLong() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));

		String encrypted = AES256.encrypt(original, bitStringKey);
		assertNull(AES256.decrypt(encrypted, bitStringKeyLong));
		
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}
	

	@Test
	/*
	 * Testing that correct Error message is shown when using a generated key of wrong length during decryption
	 */
	public void testDecryptionGeneratedKeyWrongLength() {
		System.setOut(new PrintStream(outputStreamCaptor));
		System.setErr(new PrintStream(outputErrCaptor));
		
		String strKey = "";
		try{
			KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM_AES);
			keyGen.init(256);
			SecretKey key = keyGen.generateKey();
			strKey = Base64.getEncoder().encodeToString(key.getEncoded());
		}
		catch (Exception e) {
			System.out.println(KEYGEN_ERROR +e.toString());
		}
		String strKeyWrongLength = "";
		try{
			KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM_AES);
			keyGen.init(128);
			SecretKey key = keyGen.generateKey();
			strKeyWrongLength = Base64.getEncoder().encodeToString(key.getEncoded());
		}
		catch (Exception e) {
			System.out.println(KEYGEN_ERROR +e.toString());
		}
			
		String encrypted = AES256.encrypt(original, strKey);
		assertNull(AES256.decrypt(encrypted, strKeyWrongLength));
		
		assertEquals(KEY_WRONG_SIZE, outputStreamCaptor.toString().trim());
		assertEquals(INVALID_KEY_NULL.replaceAll("\\s",""), outputErrCaptor.toString().trim().replaceAll("\\s",""));
		
		System.setOut(standardOut);
		System.setErr(standardErr);
	}

	@Test
	/*
	 * Testing that correct Exception is thrown when null is used as key during decryption
	 */
	public void testDecryptionNullKey() {
		String encrypted = AES256.encrypt(original, bitStringKey);

		assertThrows(NullPointerException.class,() -> {
			assertNull(AES256.decrypt(encrypted,(String) null));
			});
	}
	
	@Test
	/*
	 *Testing the 256 char bit string to 32 bytes array method 
	 *with extreme cases:
	 *max value
	 *min value
	 *zero
	 *and random values between 
	 */
	public void testBitString256ToByteArray32() {
		
		String bitString = "0000000011111111100000001011101010101010101010101110011110000011101010111010111011100011000011110111101111101011010101011010101010111000011101010111101011110110111110001111100001111100011111010101110101110101110101110111101111000001111111010101010111101111";
		byte[] byteArray = CryptoUtility.bitString256ToByteArray32(bitString);
		assertEquals(byteArray[0], -128);
		assertEquals(byteArray[1], 127);
		assertEquals(byteArray[2], 0);
	}
	
	@Test
	/*
	 * Testing the 256 char bit string to 32 bytes array method when using
	 * too long bit string
	 */
	public void testBitString256ToByteArray32TooLong() {
		System.setOut(new PrintStream(outputStreamCaptor));
		
		assertNull(CryptoUtility.bitString256ToByteArray32(bitStringKeyLong));
		
		assertEquals(BIT_STRING_WRONG_LENGTH, outputStreamCaptor.toString().trim());
		System.setOut(standardOut);
	}
	
	@Test
	/*
	 * Testing the 256 char bit string to 32 bytes array method when using
	 * too short bit string
	 */
	public void testBitString256ToByteArray32TooShort() {
		System.setOut(new PrintStream(outputStreamCaptor));
		
		assertNull(CryptoUtility.bitString256ToByteArray32(bitStringKeyShort));
		
		assertEquals(BIT_STRING_WRONG_LENGTH, outputStreamCaptor.toString().trim());
		System.setOut(standardOut);
	}
	
	@Test
	/*
	 * Testing the 256 char bit string to 32 bytes array method when using 
	 * null as bit string
	 */
	public void testBitString256ToByteArray32Null() {
		assertThrows(NullPointerException.class,() -> {
			assertNull(CryptoUtility.bitString256ToByteArray32(null));
		});
		
	}
	
	@Test
	/*
	 * Testing the 256 char bit string to 32 bytes array method when using
	 * chars in bit string
	 */
	public void testBitString256ToByteArray32Chars() {
		assertThrows(NumberFormatException.class,()->{
			assertNull(CryptoUtility.bitString256ToByteArray32(bitStringKeyWithChars));
		});
	}
	
	
}
